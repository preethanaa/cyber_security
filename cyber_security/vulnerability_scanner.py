from zapv2 import ZAPv2
import uuid
import time
import threading

ZAP_URL = "http://127.0.0.1:8080"
API_KEY = "16vhrldd6dptdqtu04pqg3d6"  # Replace with your actual ZAP API key

class VulnerabilityScanner:
    
    def _init_(self):
        # Initialize ZAPv2 with the API key and proxy settings
        self.zap = ZAPv2(apikey=API_KEY, proxies={'http': ZAP_URL, 'https': ZAP_URL})
        self.scans = {}  # To store scan statuses

    def start_scan(self, url):
        """
        Start a new scan for a given URL. The scan runs in a separate thread.
        Returns a unique scan ID to track the status of the scan.
        """
        scan_id = str(uuid.uuid4())  # Generate a unique scan ID
        self.scans[scan_id] = {'status': 'Running'}
        threading.Thread(target=self._run_scan, args=(scan_id, url)).start()  # Run scan in a new thread
        return scan_id

    def _run_scan(self, scan_id, url):
        """
        Private method that performs the actual scanning process.
        It starts with the spider scan and follows with the active scan.
        """
        try:
            print(f"ZAP API URL: {ZAP_URL}")
            print(f"Starting spider scan for {url}")
            spider_id = self.zap.spider.scan(url)
            time.sleep(5)  # Allow time for the spider scan to initiate

            # Wait for the spider scan to complete
            while int(self.zap.spider.status(spider_id)) < 100:
                spider_status = self.zap.spider.status(spider_id)
                print(f"Spider scan in progress: {spider_status}%")
                time.sleep(2)

            print("Spider scan completed. Starting active scan.")

            # Start the active scan
            scan_id_active = self.zap.ascan.scan(url)

            # Wait for the active scan to complete
            while int(self.zap.ascan.status(scan_id_active)) < 100:
                active_scan_status = self.zap.ascan.status(scan_id_active)
                print(f"Active scan in progress: {active_scan_status}%")
                time.sleep(2)

            print(f"Active scan for {url} completed.")
            self.scans[scan_id]['status'] = 'Completed'

        except Exception as e:
            print(f"An error occurred during the scan: {e}")
            self.scans[scan_id]['status'] = 'Error'

    def get_scan_status(self, scan_id):
        """
        Return the status of the scan using the scan ID.
        """
        return self.scans.get(scan_id, {}).get('status', 'Invalid Scan ID')

    def generate_report(self, scan_id):
        """
        Generate a report after the scan is completed. It retrieves the vulnerabilities found.
        """
        if self.get_scan_status(scan_id) == 'Completed':
            # Fetch alerts for the scanned URL
            issues = self.zap.core.alerts()
            return {'scan_id': scan_id, 'vulnerabilities': issues}
        else:
            return {'scan_id': scan_id, 'error': 'Scan not completed yet or invalid scan ID.'}

    def stop_scan(self, scan_id):
        """
        Stop the scan if it is running.
        """
        if self.get_scan_status(scan_id) == 'Running':
            # Attempt to stop both spider and active scans
            self.zap.spider.stop()
            self.zap.ascan.stop()
            self.scans[scan_id]['status'] = 'Stopped'
            print(f"Scan {scan_id} has been stopped.")
        else:
            print(f"Cannot stop scan {scan_id}: Scan is not running.")